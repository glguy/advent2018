
{-|
Module      : Main
Description : Day 16 solution
Copyright   : (c) Eric Mertens, 2018
License     : ISC
Maintainer  : emertens@gmail.com

<https://adventofcode.com/2018/day/16>
-}
{-# Language OverloadedStrings, BangPatterns, DeriveTraversable #-}
module Main (main) where

import           Advent               (Parser, getParsedInput, count, number)
import           Data.Maybe           (fromJust)
import           Data.List            (intersect, foldl')
import           Control.Monad        (foldM)
import           Data.Bits            ((.&.), (.|.))
import           Text.Megaparsec.Char (space, newline)
import           Text.Megaparsec      (many, sepBy, endBy, eof)
import qualified Data.IntMap as IntMap
import           Data.IntMap (IntMap, (!))

-- | Instructions are an opcode and 3 operands A B and C.
data Instruction = I !Int !Int !Int !Int deriving Show

-- | Examples are registers before, an instruction, and registers after.
data Example = E Registers Instruction Registers

-- | Registers are represented using an IntMap. Assume no default values
type Registers = IntMap Int

-- | Semantics take operands A, B, C and the current registers and produce
-- the resulting registers.
type Semantics = Int -> Int -> Int -> Registers -> Registers


-- | Print the answers to day 16
--
-- >>> :main
-- 592
-- 557
main :: IO ()
main =
  do (examples, instructions) <- getParsedInput 16 parseLine
     print (part1 examples)
     print (part2 examples instructions)

-- registers -----------------------------------------------------------

toRegisters :: [Int] -> Registers
toRegisters = IntMap.fromList . zip [0..]

-- parsing -------------------------------------------------------------

parseLine :: Parser ([Example], [Instruction])
parseLine = (,) <$> many parseExample
                <* newline <* newline
                <*> endBy parseInstruction newline
                <* eof

parseExample :: Parser Example
parseExample =
  E <$  "Before: " <*> parseRegisters <* newline
    <*> parseInstruction <* newline
    <*  "After:  " <*> parseRegisters <* newline
    <* newline

parseRegisters :: Parser Registers
parseRegisters = toRegisters <$ "[" <*> sepBy number ", " <* "]"

parseInstruction :: Parser Instruction
parseInstruction = I <$> number <* space <*> number <* space
                     <*> number <* space <*> number

-- semantics -----------------------------------------------------------

-- | Pairs of opcode names and semantics
opcodes :: [(String, Semantics)]
opcodes =
  [ ("addr", \a b c regs -> IntMap.insert c (regs ! a +   regs ! b) regs)
  , ("addi", \a b c regs -> IntMap.insert c (regs ! a +          b) regs)

  , ("mulr", \a b c regs -> IntMap.insert c (regs ! a *   regs ! b) regs)
  , ("muli", \a b c regs -> IntMap.insert c (regs ! a *          b) regs)

  , ("banr", \a b c regs -> IntMap.insert c (regs ! a .&. regs ! b) regs)
  , ("bani", \a b c regs -> IntMap.insert c (regs ! a .&.        b) regs)

  , ("borr", \a b c regs -> IntMap.insert c (regs ! a .|. regs ! b) regs)
  , ("bori", \a b c regs -> IntMap.insert c (regs ! a .|.        b) regs)

  , ("setr", \a _ c regs -> IntMap.insert c (regs ! a             ) regs)
  , ("seti", \a _ c regs -> IntMap.insert c (       a             ) regs)

  , ("gtir", \a b c regs -> IntMap.insert c (if        a > regs ! b then 1 else 0) regs)
  , ("gtri", \a b c regs -> IntMap.insert c (if regs ! a >        b then 1 else 0) regs)
  , ("gtrr", \a b c regs -> IntMap.insert c (if regs ! a > regs ! b then 1 else 0) regs)

  , ("eqir", \a b c regs -> IntMap.insert c (if        a == regs ! b then 1 else 0) regs)
  , ("eqri", \a b c regs -> IntMap.insert c (if regs ! a ==        b then 1 else 0) regs)
  , ("eqrr", \a b c regs -> IntMap.insert c (if regs ! a == regs ! b then 1 else 0) regs)
  ]

-- tasks ---------------------------------------------------------------

-- | How many samples in your puzzle input behave like three or more opcodes?
part1 :: [Example] -> Int
part1 = Advent.count $ \example -> 3 <= length (snd (getMatches example))

-- | What value is contained in register 0 after executing the test program?
part2 :: [Example] -> [Instruction] -> Int
part2 examples program = finalRegs ! 0
  where
    finalRegs = foldl' eval (toRegisters [0,0,0,0]) program

    semantics = assignments (getConstraints examples)

    eval regs (I o a b c) = (semantics IntMap.! o) a b c regs

-- constraints and assignments -----------------------------------------

-- | Given an example extract the opcode and possible name for it.
--
-- >>> getMatches (toRegisters [3,2,1,1], I 9 2 1 2, toRegisters [3,2,2,1])
-- (9,["addi","mulr","seti"])
getMatches :: Example -> (Int, [String])
getMatches (E before (I o a b c) after) =
    (o, [ name | (name,f) <- opcodes, after == (f a b c before) ])

-- | Get the constraints generated by a list of examples. Each opcode key is
-- associated with a list of possible opcode names.
--
-- >>> getConstraints [(toRegisters  [3,2,1,1], I 9 2 1 2, toRegisters [3,2,2,1])]
-- fromList [(9,["addi","mulr","seti"])]
getConstraints :: [Example] -> IntMap [String]
getConstraints examples = IntMap.fromListWith intersect (map getMatches examples)

-- | Given all of the constraints for opcodes, compute their semantics
assignments :: IntMap [String] -> IntMap Semantics
assignments constraints = fmap (\name -> fromJust (lookup name opcodes)) nameMap
  where
    [nameMap] = foldM pick IntMap.empty (IntMap.toList constraints)

    pick soFar (o, possible) =
      [ IntMap.insert o picked soFar
          | picked <- possible
          , picked `notElem` soFar ]

